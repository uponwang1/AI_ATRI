<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <title>æ°£è±¡è³‡æ–™åˆ†æèˆ‡ç©æº«æ¯”è¼ƒ v8.1</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: "Microsoft JhengHei"; margin: 40px; }
        canvas { width: 100%; height: 420px !important; margin-bottom: 40px; }
        table { border-collapse: collapse; width: 100%; margin-top: 25px; }
        th, td { border: 1px solid #ddd; padding: 6px; text-align: center; }
        th { background-color: #f2f2f2; }
        .control-panel, .gdd-panel { margin: 20px 0; }
        .btn { padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; margin-right: 6px; }
        .btn-upload { background-color: #007bff; color: white; }
        .btn-clear { background-color: #dc3545; color: white; }
        .btn-calc { background-color: #28a745; color: white; }
    </style>
</head>
<body>
    <h2>ğŸ“Š æ°£è±¡è³‡æ–™ä¸Šå‚³èˆ‡åˆ†æ v8.1</h2>

    <div class="control-panel">
        <form method="POST" enctype="multipart/form-data" style="display:inline-block;">
            <input type="file" name="files" accept=".csv" multiple required>
            <button type="submit" class="btn btn-upload">ğŸ“„ æ‰¹æ¬¡ä¸Šå‚³å¤šå€‹ CSV</button>
        </form>
        <form method="POST" action="/clear" style="display:inline-block;">
            <button type="submit" class="btn btn-clear">ğŸ§¹ æ¸…ç©ºè³‡æ–™åº«</button>
        </form>
    </div>

    <hr>

    <h3>ğŸ“ˆ æ°£è±¡åœ–è¡¨</h3>
    <label>ç¬¬ä¸€æ•¸æ“šï¼ˆå·¦è»¸ï¼‰ï¼š</label>
    <select id="data1">
        <option value="">ï¼ˆä¸é¸ï¼‰</option>
        <option value="temperature">æ°£æº« (Â°C)</option>
        <option value="humidity">ç›¸å°æº¼åº¦ (%)</option>
        <option value="tmax">æœ€é«˜æ°£æº« (Â°C)</option>
        <option value="tmin">æœ€ä½æ°£æº« (Â°C)</option>
    </select>

    <label>ç¬¬äºŒæ•¸æ“šï¼ˆå³è»¸ï¼‰ï¼š</label>
    <select id="data2">
        <option value="">ï¼ˆä¸é¸ï¼‰</option>
        <option value="humidity">ç›¸å°æº¼åº¦ (%)</option>
        <option value="temperature">æ°£æº« (Â°C)</option>
        <option value="tmax">æœ€é«˜æ°£æº« (Â°C)</option>
        <option value="tmin">æœ€ä½æ°£æº« (Â°C)</option>
    </select>

    <label>ç¯©é¸æ—¥æœŸï¼š</label>
    <input type="date" id="startDate">
    <input type="date" id="endDate">
    <button onclick="updateChart()">æ›´æ–°åœ–è¡¨</button>

    <canvas id="weatherChart"></canvas>

    <hr>
    <h3>ğŸŒ¾ ç©æº« (GDD) ä¸‰æ®µæ¯”è¼ƒ</h3>
    <div class="gdd-panel">
        <p>ç¬¬ä¸€æ®µï¼š<input type="date" id="start1"> ~ <input type="date" id="end1"></p>
        <p>ç¬¬äºŒæ®µï¼š<input type="date" id="start2"> ~ <input type="date" id="end2"></p>
        <p>ç¬¬ä¸‰æ®µï¼š<input type="date" id="start3"> ~ <input type="date" id="end3"></p>
        <button class="btn btn-calc" onclick="calcGDD()">è¨ˆç®—ä¸‰æ®µç©æº«</button>
    </div>

    <div id="gddResult"></div>

    <script>
        const rawData = {{ data | tojson }};
        const labelsFull = rawData.map(r => r[0]);
        const tempsFull  = rawData.map(r => parseFloat(r[1]));
        const humsFull   = rawData.map(r => parseFloat(r[2]));
        const tmaxFull   = rawData.map(r => parseFloat(r[3]));
        const tminFull   = rawData.map(r => parseFloat(r[4]));

        const ctx = document.getElementById('weatherChart').getContext('2d');
        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labelsFull,
                datasets: [
                    { label: 'æ°£æº« (Â°C)',    data: tempsFull, borderColor: 'red',    borderWidth: 2, yAxisID: 'y1', hidden: true },
                    { label: 'ç›¸å°æº¼åº¦ (%)',  data: humsFull,  borderColor: 'blue',   borderWidth: 2, yAxisID: 'y2', hidden: true },
                    { label: 'æœ€é«˜æ°£æº« (Â°C)', data: tmaxFull,  borderColor: 'orange', borderWidth: 2, yAxisID: 'y1', hidden: true },
                    { label: 'æœ€ä½æ°£æº« (Â°C)', data: tminFull,  borderColor: 'green',  borderWidth: 2, yAxisID: 'y1', hidden: true }
                ]
            },
            options: {
                responsive: true,
                interaction: { mode: 'index', intersect: false },
                stacked: false,
                scales: {
                    y1: { type: 'linear', position: 'left',  title: { display: true, text: 'æ•¸å€¼' } },
                    y2: { type: 'linear', position: 'right', title: { display: true, text: 'æ•¸å€¼' }, grid: { drawOnChartArea: false } }
                }
            }
        });

        // åˆå§‹åŒ–ï¼ˆé è¨­ä¸é¡¯ç¤ºï¼Œç­‰ä½ é¸ï¼‰
        updateChart();

        function updateChart() {
            const selected1 = document.getElementById("data1").value; // å·¦è»¸
            const selected2 = document.getElementById("data2").value; // å³è»¸
            const start = document.getElementById("startDate").value;
            const end   = document.getElementById("endDate").value;

            // 1) å…ˆæ±ºå®šé¡¯ç¤ºçš„æ—¥æœŸå€é–“ç´¢å¼•
            let sIdx = 0, eIdx = labelsFull.length - 1;
            if (start && end) {
                const si = labelsFull.indexOf(start);
                const ei = labelsFull.indexOf(end);
                if (si !== -1) sIdx = si;
                if (ei !== -1) eIdx = ei;
                if (eIdx < sIdx) { const t = sIdx; sIdx = ei; eIdx = t; }
            }

            // 2) ç”¢ç”Ÿåˆ‡å¾Œè³‡æ–™ï¼ˆä¹‹å¾Œæ‰€æœ‰ min/max éƒ½ç”¨å®ƒï¼‰
            const labelsS = labelsFull.slice(sIdx, eIdx + 1);
            const tempsS  = tempsFull.slice(sIdx, eIdx + 1);
            const humsS   = humsFull.slice(sIdx, eIdx + 1);
            const tmaxS   = tmaxFull.slice(sIdx, eIdx + 1);
            const tminS   = tminFull.slice(sIdx, eIdx + 1);

            // 3) é¡¯ç¤ºè³‡æ–™é›†èˆ‡åº§æ¨™è»¸æ­¸å±¬
            const mapKeyToIdx = { temperature: 0, humidity: 1, tmax: 2, tmin: 3 };
            const ds = chart.data.datasets;
            ds.forEach(d => d.hidden = true);

            const activeSelections = [selected1, selected2].filter(v => v !== "");

            // æ²’é¸æ“‡ä»»ä½•æ•¸æ“š â†’ æ¸…ç©ºåœ–è¡¨ï¼ˆåªä¿ç•™ labelsï¼‰
            if (activeSelections.length === 0) {
                chart.data.labels = labelsS;
                ds.forEach(d => d.data = []);
                chart.options.scales.y1.min = chart.options.scales.y1.max = undefined;
                chart.options.scales.y2.min = chart.options.scales.y2.max = undefined;
                chart.update();
                return;
            }

            if (selected1) {
                ds[mapKeyToIdx[selected1]].hidden = false;
                ds[mapKeyToIdx[selected1]].yAxisID = 'y1';
            }
            if (selected2) {
                ds[mapKeyToIdx[selected2]].hidden = false;
                ds[mapKeyToIdx[selected2]].yAxisID = 'y2';
            }

            // 4) å¥—ç”¨åˆ‡å¾Œè³‡æ–™åˆ° datasets
            chart.data.labels = labelsS;
            ds[0].data = tempsS;
            ds[1].data = humsS;
            ds[2].data = tmaxS;
            ds[3].data = tminS;

            // 5) è¨ˆç®—è»¸ç¯„åœï¼ˆä»¥åˆ‡å¾Œè³‡æ–™ç‚ºæº–ï¼‰
            const dataByIdx = { 0: tempsS, 1: humsS, 2: tmaxS, 3: tminS };
            const sel1Arr = selected1 ? dataByIdx[mapKeyToIdx[selected1]].filter(Number.isFinite) : [];
            const sel2Arr = selected2 ? dataByIdx[mapKeyToIdx[selected2]].filter(Number.isFinite) : [];

            // é è¨­æ¸…ç©º min/maxï¼ˆäº¤çµ¦ Chart.js è‡ªå‹•ï¼‰
            chart.options.scales.y1.min = chart.options.scales.y1.max = undefined;
            chart.options.scales.y2.min = chart.options.scales.y2.max = undefined;

            const bothSelected = !!selected1 && !!selected2;
            const bothNonHumidity = bothSelected && selected1 !== "humidity" && selected2 !== "humidity";

            if (bothNonHumidity) {
                // â˜… å…©è€…çš†éæ¿•åº¦ â†’ å·¦å³è»¸å¼·åˆ¶ç›¸åŒç¯„åœ
                const combined = sel1Arr.concat(sel2Arr);
                if (combined.length) {
                    const minV = Math.min(...combined);
                    const maxV = Math.max(...combined);
                    chart.options.scales.y1.min = chart.options.scales.y2.min = Math.floor(minV - 1);
                    chart.options.scales.y1.max = chart.options.scales.y2.max = Math.ceil (maxV + 1);
                }
            } else {
                if (sel1Arr.length) {
                    chart.options.scales.y1.min = Math.floor(Math.min(...sel1Arr) - 1);
                    chart.options.scales.y1.max = Math.ceil (Math.max(...sel1Arr) + 1);
                }
                if (sel2Arr.length) {
                    chart.options.scales.y2.min = Math.floor(Math.min(...sel2Arr) - 1);
                    chart.options.scales.y2.max = Math.ceil (Math.max(...sel2Arr) + 1);
                }
            }

            chart.update();
        }

        async function calcGDD() {
            const start1 = document.getElementById("start1");
            const end1   = document.getElementById("end1");
            const start2 = document.getElementById("start2");
            const end2   = document.getElementById("end2");
            const start3 = document.getElementById("start3");
            const end3   = document.getElementById("end3");

            const payload = {
                range1: [start1.value, end1.value],
                range2: [start2.value, end2.value],
                range3: [start3.value, end3.value]
            };
            const res = await fetch("/gdd_compare", {
                method: "POST",
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify(payload)
            });
            const data = await res.json();

            let html = "<table border='1' cellpadding='5'><tr><th>Tb</th><th>GDD1</th><th>GDD2</th><th>GDD3</th><th>æ¨™æº–å·®</th></tr>";
            data.table.forEach(r => {
                const highlight = r.Tb === data.best.Tb ? "style='background:yellow;'" : "";
                html += `<tr ${highlight}><td>${r.Tb}</td><td>${r.GDD1}</td><td>${r.GDD2}</td><td>${r.GDD3}</td><td>${r.std}</td></tr>`;
            });
            html += "</table><p>ğŸŒ¾ æœ€ç©©å®šçš„åŸºæº–æº«åº¦ Tb = <b>" + data.best.Tb + "Â°C</b></p>";
            document.getElementById("gddResult").innerHTML = html;
        }
        document.addEventListener("DOMContentLoaded", () => {
    // ===== GDD ä¸‰æ®µæ¯”è¼ƒï¼šé è¨­æ—¥æœŸï¼ˆæ›´ç©© + ä¸è¦†è“‹ä½¿ç”¨è€…å·²å¡«å€¼ï¼‰ =====
    const defaults = {
        start1: "2025-02-17",
        end1:   "2025-05-02",
        start2: "2025-06-24",
        end2:   "2025-07-30",
        start3: "2025-09-19",
        end3:   "2025-10-20"
    };

    for (const [id, val] of Object.entries(defaults)) {
        const el = document.getElementById(id);
        if (!el) continue;          // é˜²å‘†ï¼šå…ƒç´ ä¸å­˜åœ¨å°±è·³é
        if (el.value) continue;     // é˜²å‘†ï¼šä½¿ç”¨è€…å·²ç¶“å¡«å€¼å°±ä¸è¦†è“‹
        el.value = val;
    }
});

    </script>

    <hr>
    <h3>ğŸ“‹ è³‡æ–™åº«å…§æ‰€æœ‰ç´€éŒ„</h3>
    <table>
        <tr>
            <th>æ—¥æœŸ</th>
            <th>æ°£æº« (Â°C)</th>
            <th>ç›¸å°æº¼åº¦ (%)</th>
            <th>æœ€é«˜æ°£æº« (Â°C)</th>
            <th>æœ€ä½æ°£æº« (Â°C)</th>
        </tr>
        {% for row in data %}
        <tr>
            <td>{{ row[0] }}</td>
            <td>{{ row[1] }}</td>
            <td>{{ row[2] }}</td>
            <td>{{ row[3] }}</td>
            <td>{{ row[4] }}</td>
        </tr>
        {% endfor %}
    </table>
</body>
</html>


